name: Veil — Reusable SBG
on:
  workflow_call:

permissions:
  contents: read
  security-events: read
  pull-requests: write

jobs:
  sbg:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const results = [];
            const fail = (m, l) => results.push({ t: 'fail', m, l });
            const warn = (m, l) => results.push({ t: 'warn', m, l });
            const passm = (m) => results.push({ t: 'pass', m });

            // SECURITY.md
            let hasSec = false;
            for (const p of ['SECURITY.md', '.github/SECURITY.md']) {
              try { await github.rest.repos.getContent({ owner, repo, path: p }); hasSec = true; break; } catch {}
            }
            if (!hasSec) fail('Missing SECURITY.md','https://docs.github.com/en/code-security/getting-started/adding-a-security-policy-to-your-repository');

            // Dependabot config
            try { await github.rest.repos.getContent({ owner, repo, path: '.github/dependabot.yml' }); }
            catch { fail('Missing .github/dependabot.yml','https://docs.github.com/en/code-security/dependabot/working-with-dependabot/dependabot-options-reference'); }

            // Code scanning reachability
            try { await github.rest.codeScanning.listAlertsForRepo({ owner, repo, per_page: 1 }); passm('Code Scanning API reachable'); }
            catch { warn('Enable Code Scanning (Default setup)','https://docs.github.com/en/code-security/code-scanning/enabling-code-scanning'); }

            // Secret scanning reminder
            warn('Verify Secret Scanning & Push Protection are enabled','https://docs.github.com/en/code-security/secret-scanning/enabling-secret-scanning-features/enabling-push-protection-for-your-repository');

            // Dependency graph
            let depGraphStatus = 'unknown';
            try {
              const repoInfo = await github.rest.repos.get({ owner, repo });
              depGraphStatus = repoInfo.data?.security_and_analysis?.dependency_graph?.status || 'unknown';
            } catch {}
            if (depGraphStatus !== 'enabled') warn('Enable Dependency graph in settings','https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph');
            else passm('Dependency graph enabled');

            // SBOM presence (common filenames)
            let hasSBOM = false;
            try {
              const repoInfo = await github.rest.repos.get({ owner, repo });
              const def = repoInfo.data.default_branch;
              const ref = await github.rest.git.getRef({ owner, repo, ref: `heads/${def}` });
              const tree = await github.rest.git.getTree({ owner, repo, tree_sha: ref.data.object.sha, recursive: '1' });
              const re = /(^|\/)(sbom|bom)\.(json|xml|cdx|spdx(\.json)?)(\.gz)?$/i;
              hasSBOM = tree.data.tree.some(t => t.type === 'blob' && re.test(t.path));
            } catch {}
            if (hasSBOM) passm('SBOM file detected');
            else warn('No SBOM detected (add CycloneDX or SPDX, or use Dependency Submission)','https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/generating-a-software-bill-of-materials-sbom');

            // Output + sticky PR comment
            const failed = results.some(r => r.t === 'fail');
            let body = `# Veil — Security Baseline Gate\n\n| Status | Check |\n|---|---|\n`;
            for (const r of results) {
              const icon = r.t === 'fail' ? '❌' : r.t === 'warn' ? '⚠️' : '✅';
              const line = r.l ? `[${r.m}](${r.l})` : r.m;
              body += `| ${icon} | ${line} |\n`;
            }
            await core.summary.addRaw(body).write();

            if (context.payload.pull_request) {
              const issue_number = context.payload.pull_request.number;
              const marker = '<!-- veil-sbg -->';
              const commentBody = `${marker}\n${body}\n`;
              const comments = await github.rest.issues.listComments({ owner, repo, issue_number, per_page: 100 });
              const prior = comments.data.find(c => c.body && c.body.includes(marker));
              if (prior) await github.rest.issues.updateComment({ owner, repo, comment_id: prior.id, body: commentBody });
              else await github.rest.issues.createComment({ owner, repo, issue_number, body: commentBody });
            }

            if (failed) core.setFailed('Veil baseline checks failed.');
